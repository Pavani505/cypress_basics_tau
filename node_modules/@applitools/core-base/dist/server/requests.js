"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeFunctionalSessionRequests = exports.makeEyesRequests = exports.makeCoreRequestsWithCache = void 0;
const logger_1 = require("@applitools/logger");
const req_eyes_1 = require("./req-eyes");
const upload_1 = require("./upload");
const utils = __importStar(require("@applitools/utils"));
exports.makeCoreRequestsWithCache = utils.general.cachify(makeCoreRequests, () => 'default');
function makeCoreRequests({ fetch, logger: defaultLogger } = {}) {
    const mainLogger = (0, logger_1.makeLogger)({ logger: defaultLogger, format: { label: 'core-requests' } });
    const getAccountInfoWithCache = utils.general.cachify(getAccountInfo, ([{ settings }]) => {
        return [settings.eyesServerUrl, settings.apiKey, settings.proxy];
    });
    const getBatchBranchesWithCache = utils.general.cachify(getBatchBranches, ([{ settings }]) => {
        return [settings.batchId, settings.eyesServerUrl, settings.apiKey, settings.proxy];
    });
    const core = {
        concurrency: undefined,
        getAccountInfo: getAccountInfoWithCache,
        getBatchBranches: getBatchBranchesWithCache,
        openEyes,
        openFunctionalSession,
        locate,
        locateText,
        extractText,
        closeBatch,
        deleteTest,
        logEvent,
        sendHeartbeat,
    };
    return core;
    async function openEyes({ settings, heartbeat, logger = mainLogger, }) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "openEyes" called with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        if (account.processKeepaliveIntervalSec) {
            heartbeat.startPeriodicHeartbeatMessaging({
                eyesServerUrl: settings.eyesServerUrl,
                apiKey: settings.apiKey,
                proxy: settings.proxy,
                useDnsCache: settings.useDnsCache,
                agentId: settings.agentId,
                processId: settings.processId,
                interval: (_a = utils.general.getEnvValue('HEARTBEAT_INTERVAL', 'number')) !== null && _a !== void 0 ? _a : account.processKeepaliveIntervalSec * 1000,
            });
        }
        const initializedAt = new Date().toISOString();
        const response = await req('./api/sessions/running', {
            name: 'openEyes',
            method: 'POST',
            body: {
                startInfo: {
                    agentId: settings.agentId,
                    agentSessionId: settings.userTestId,
                    agentRunId: settings.userTestId,
                    sessionType: settings.sessionType,
                    appIdOrName: settings.appName,
                    scenarioIdOrName: settings.testName,
                    displayName: settings.displayName,
                    properties: [...((_b = settings.properties) !== null && _b !== void 0 ? _b : []), ...((_d = (_c = settings.environment) === null || _c === void 0 ? void 0 : _c.properties) !== null && _d !== void 0 ? _d : [])],
                    batchInfo: settings.batch && {
                        id: settings.batch.id,
                        name: settings.batch.name,
                        batchSequenceName: settings.batch.sequenceName,
                        startedAt: settings.batch.startedAt,
                        notifyOnCompletion: settings.batch.notifyOnCompletion,
                        properties: settings.batch.properties,
                        buildId: settings.batch.buildId,
                    },
                    egSessionId: (_f = (_e = settings.environment) === null || _e === void 0 ? void 0 : _e.ecSessionId) !== null && _f !== void 0 ? _f : null,
                    environment: settings.environment &&
                        (settings.environment.rawEnvironment
                            ? {
                                ...settings.environment.rawEnvironment,
                                os: (_g = settings.environment.os) !== null && _g !== void 0 ? _g : settings.environment.rawEnvironment.os,
                                osInfo: (_h = settings.environment.displayOs) !== null && _h !== void 0 ? _h : settings.environment.rawEnvironment.osInfo,
                                hostingApp: (_j = settings.environment.hostingApp) !== null && _j !== void 0 ? _j : settings.environment.rawEnvironment.hostingApp,
                                hostingAppInfo: (_k = settings.environment.displayHostingApp) !== null && _k !== void 0 ? _k : settings.environment.rawEnvironment.hostingAppInfo,
                            }
                            : {
                                deviceInfo: settings.environment.deviceName,
                                os: settings.environment.os,
                                osInfo: settings.environment.displayOs,
                                hostingApp: settings.environment.hostingApp,
                                hostingAppInfo: settings.environment.displayHostingApp,
                                displaySize: settings.environment.viewportSize
                                    ? utils.geometry.round(settings.environment.viewportSize)
                                    : { width: 0, height: 0 },
                                inferred: settings.environment.userAgent && `useragent:${settings.environment.userAgent}`,
                            }),
                    environmentName: settings.environmentName,
                    baselineEnvName: settings.baselineEnvName,
                    branchName: settings.branchName,
                    parentBranchName: settings.parentBranchName,
                    baselineBranchName: settings.baselineBranchName,
                    compareWithParentBranch: settings.compareWithParentBranch,
                    parentBranchBaselineSavedBefore: settings.gitBranchingTimestamp,
                    ignoreBaseline: settings.ignoreBaseline,
                    saveDiffs: settings.saveDiffs,
                    timeout: settings.abortIdleTestTimeout,
                    isComponentAgent: settings.isComponentTest,
                    fallbackExpectedOutput: settings.fallbackBaselineId,
                    latestCommitInfo: settings.latestCommitInfo,
                    processId: settings.processId,
                },
            },
            expected: [200, 201],
            logger,
        });
        const test = await response.json().then(async (result) => {
            var _a, _b, _c;
            return {
                testId: result.id,
                // TODO revisit the need for it
                testName: settings.testName,
                userTestId: settings.userTestId,
                batchId: (_b = (_a = settings.batch) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : result.batchId,
                baselineId: result.baselineId,
                sessionId: result.sessionId,
                initializedAt,
                appId: settings.appName,
                isNew: (_c = result.isNew) !== null && _c !== void 0 ? _c : response.status === 201,
                keepBatchOpen: !!settings.keepBatchOpen,
                keepIfDuplicate: !!settings.baselineEnvName,
                resultsUrl: result.url,
                eyesServer: account.eyesServer,
                ufgServer: account.ufgServer,
                uploadUrl: account.uploadUrl,
                supportedEnvironmentsUrl: account.supportedEnvironmentsUrl,
                stitchingServiceUrl: account.stitchingServiceUrl,
                account,
                environment: settings.environment,
            };
        });
        logger.log('Request "openEyes" finished successfully with body', test);
        return makeEyesRequests({ core, test, req, logger });
    }
    async function openFunctionalSession({ settings, logger = mainLogger, }) {
        var _a, _b, _c, _d, _e;
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "openFunctionalSession" called with settings', settings);
        const accountPromise = getAccountInfoWithCache({ settings });
        const initializedAt = new Date().toISOString();
        const response = await req('./api/sessions/running', {
            name: 'openFunctionalSession',
            method: 'POST',
            body: {
                startInfo: {
                    agentId: settings.agentId,
                    agentSessionId: settings.userTestId,
                    agentRunId: settings.userTestId,
                    sessionType: settings.sessionType,
                    appIdOrName: settings.appName,
                    scenarioIdOrName: settings.testName,
                    displayName: settings.displayName,
                    properties: [...((_a = settings.properties) !== null && _a !== void 0 ? _a : []), ...((_c = (_b = settings.environment) === null || _b === void 0 ? void 0 : _b.properties) !== null && _c !== void 0 ? _c : [])],
                    batchInfo: settings.batch && {
                        id: settings.batch.id,
                        name: settings.batch.name,
                        batchSequenceName: settings.batch.sequenceName,
                        startedAt: settings.batch.startedAt,
                        notifyOnCompletion: settings.batch.notifyOnCompletion,
                        properties: settings.batch.properties,
                        buildId: settings.batch.buildId,
                    },
                    egSessionId: (_e = (_d = settings.environment) === null || _d === void 0 ? void 0 : _d.ecSessionId) !== null && _e !== void 0 ? _e : null,
                    environment: settings.environment &&
                        (settings.environment.rawEnvironment
                            ? {
                                ...settings.environment.rawEnvironment,
                                os: settings.environment.os,
                                osInfo: settings.environment.displayOs,
                                hostingApp: settings.environment.hostingApp,
                                hostingAppInfo: settings.environment.displayHostingApp,
                            }
                            : {
                                deviceInfo: settings.environment.deviceName,
                                os: settings.environment.os,
                                osInfo: settings.environment.displayOs,
                                hostingApp: settings.environment.hostingApp,
                                hostingAppInfo: settings.environment.displayHostingApp,
                                displaySize: settings.environment.viewportSize
                                    ? utils.geometry.round(settings.environment.viewportSize)
                                    : { width: 0, height: 0 },
                                inferred: settings.environment.userAgent && `useragent:${settings.environment.userAgent}`,
                            }),
                    timeout: settings.abortIdleTestTimeout,
                    nonVisual: true,
                },
            },
            expected: [200, 201],
            logger,
        });
        const test = await response.json().then(async (result) => {
            var _a, _b;
            const account = await accountPromise;
            return {
                testId: result.id,
                userTestId: settings.userTestId,
                batchId: (_b = (_a = settings.batch) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : result.batchId,
                sessionId: result.sessionId,
                appId: settings.appName,
                resultsUrl: result.url,
                initializedAt,
                keepBatchOpen: !!settings.keepBatchOpen,
                keepIfDuplicate: !!settings.baselineEnvName,
                eyesServer: account.eyesServer,
                account,
                environment: settings.environment,
            };
        });
        logger.log('Request "openFunctionalSession" finished successfully with body', test);
        return makeFunctionalSessionRequests({ core, test, req, logger });
    }
    async function locate({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "locate" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ settings: { uploadUrl: account.uploadUrl, proxy: account.eyesServer.proxy }, logger });
        target.image = await upload({ name: 'image', resource: target.image });
        const response = await req('./api/locators/locate', {
            name: 'locate',
            method: 'POST',
            body: {
                imageUrl: target.image,
                appName: settings.appName,
                locatorNames: settings.locatorNames,
                firstOnly: settings.firstOnly,
            },
            expected: 200,
            logger,
        });
        const result = await response.json().then((results) => {
            return settings.locatorNames.reduce((regions, locatorName) => {
                var _a, _b;
                regions[locatorName] = (_b = (((_a = results[locatorName]) !== null && _a !== void 0 ? _a : []))) === null || _b === void 0 ? void 0 : _b.map(region => ({ x: region.left, y: region.top, width: region.width, height: region.height })).sort((region1, region2) => {
                    if (region1.y !== region2.y)
                        return region1.y > region2.y ? 1 : -1;
                    else
                        return region1.x > region2.x ? 1 : -1;
                });
                return regions;
            }, {});
        });
        logger.log('Request "locate" finished successfully with body', result);
        return result;
    }
    async function locateText({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "locateText" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ settings: { uploadUrl: account.uploadUrl, proxy: account.eyesServer.proxy }, logger });
        [target.image, target.dom] = await Promise.all([
            upload({ name: 'image', resource: target.image }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true }),
        ]);
        const response = await req('./api/sessions/running/images/textregions', {
            name: 'locateText',
            method: 'POST',
            body: {
                appOutput: {
                    screenshotUrl: target.image,
                    domUrl: target.dom,
                    location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
                },
                patterns: settings.patterns,
                ignoreCase: settings.ignoreCase,
                firstOnly: settings.firstOnly,
                language: settings.language,
            },
            expected: 200,
            logger,
        });
        const result = await response.json();
        logger.log('Request "locateText" finished successfully with body', result);
        return result;
    }
    async function extractText({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "extractText" called for target', target, 'with settings', settings);
        const account = await getAccountInfoWithCache({ settings });
        const upload = (0, upload_1.makeUpload)({ settings: { uploadUrl: account.uploadUrl, proxy: account.eyesServer.proxy }, logger });
        [target.image, target.dom] = await Promise.all([
            upload({ name: 'image', resource: target.image }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true }),
        ]);
        const response = await req('./api/sessions/running/images/text', {
            name: 'extractText',
            method: 'POST',
            body: {
                appOutput: {
                    screenshotUrl: target.image,
                    domUrl: target.dom,
                    location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
                },
                regions: target.size && [{ left: 0, top: 0, ...utils.geometry.round(target.size), expected: settings.hint }],
                minMatch: settings.minMatch,
                language: settings.language,
            },
            expected: 200,
            logger,
        });
        const result = await response.json();
        logger.log('Request "extractText" finished successfully with body', result);
        return result;
    }
    async function getAccountInfo({ settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "getAccountInfo" called with settings', settings);
        const response = await req('./api/sessions/renderinfo', {
            name: 'getAccountInfo',
            method: 'GET',
            expected: 200,
            logger,
        });
        const result = await response.json().then(result => {
            const { serviceUrl: ufgServerUrl, accessToken, mobileDevicesListUrl: supportedEnvironmentsUrl, resultsUrl: uploadUrl, ...rest } = result;
            return {
                eyesServer: {
                    eyesServerUrl: settings.eyesServerUrl,
                    apiKey: settings.apiKey,
                    agentId: settings.agentId,
                    proxy: settings.proxy,
                    useDnsCache: settings.useDnsCache,
                },
                ufgServer: {
                    ufgServerUrl,
                    accessToken,
                    agentId: settings.agentId,
                    proxy: settings.proxy,
                    useDnsCache: settings.useDnsCache,
                },
                supportedEnvironmentsUrl,
                uploadUrl,
                ...rest,
            };
        });
        logger.log('Request "getAccountInfo" finished successfully with body', result);
        return result;
    }
    async function getBatchBranches({ settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "getBatchBranches" called with settings', settings);
        const response = await req(`./api/sessions/batches/${settings.batchId}/config/bypointerId`, {
            name: 'getBatchBranches',
            method: 'GET',
            logger,
        });
        const result = response.status === 200
            ? await response.json().then((result) => {
                return { branchName: result.scmSourceBranch, parentBranchName: result.scmTargetBranch };
            })
            : { branchName: undefined, parentBranchName: undefined };
        logger.log('Request "getBatchBranches" finished successfully with body', result);
        return result;
    }
    async function closeBatch({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "closeBatch" called with settings', settings);
        await req(settings.batchBuildId
            ? `./api/sessions/batches/${settings.batchId}/${settings.batchBuildId}/close/bypointerId`
            : `./api/sessions/batches/${settings.batchId}/close/bypointerId`, {
            name: 'closeBatch',
            method: 'DELETE',
            expected: 200,
            logger,
        });
        logger.log('Request "closeBatch" finished successfully');
    }
    async function deleteTest({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "deleteTest" called with settings', settings);
        await req(`./api/sessions/batches/${settings.batchId}/${settings.testId}`, {
            name: 'deleteTest',
            method: 'DELETE',
            query: {
                accessToken: settings.secretToken,
            },
            expected: 200,
            logger,
        });
        logger.log('Request "deleteTest" finished successfully');
    }
    async function logEvent({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        settings = utils.types.isArray(settings) ? settings : [settings];
        const req = (0, req_eyes_1.makeReqEyes)({ settings: settings[0], fetch, logger });
        logger.log('Request "logEvent" called with settings', settings);
        await req(`./api/sessions/log`, {
            name: 'logEvent',
            method: 'POST',
            body: {
                events: settings.map(settings => {
                    var _a, _b;
                    return {
                        event: settings.event,
                        level: (_a = settings.level) !== null && _a !== void 0 ? _a : 'Info',
                        timestamp: (_b = settings.timestamp) !== null && _b !== void 0 ? _b : new Date().toISOString(),
                    };
                }),
            },
            expected: 200,
            logger,
        });
        logger.log('Request "logEvent" finished successfully');
    }
    async function sendHeartbeat({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        const req = (0, req_eyes_1.makeReqEyes)({ settings, fetch, logger });
        logger.log('Request "heartbeat" called with settings', settings);
        await req(`./api/sessions/sdkprocess/keepalive`, {
            name: 'heartbeat',
            method: 'POST',
            body: {
                processId: settings.processId,
            },
            hooks: {
                afterError({ error }) {
                    if (error.message.includes('Bad Request(400)')) {
                        error.message = 'This process is expired. All its sessions were abandoned';
                    }
                },
            },
            retry: {
                limit: 0,
            },
            expected: 200,
            logger,
        });
        logger.log('Request "heartbeat" finished successfully');
    }
}
function makeEyesRequests({ core, test, req: defaultReq, fetch, logger: mainLogger, }) {
    let resultResponsePromise;
    let supportsCheckAndClose = true;
    let abortReason;
    const req = defaultReq !== null && defaultReq !== void 0 ? defaultReq : (0, req_eyes_1.makeReqEyes)({ settings: test.eyesServer, fetch, logger: mainLogger });
    const upload = (0, upload_1.makeUpload)({
        settings: { uploadUrl: test.account.uploadUrl, proxy: test.eyesServer.proxy },
        logger: mainLogger,
    });
    const eyes = {
        core,
        test,
        get running() {
            return !resultResponsePromise;
        },
        check,
        checkAndClose,
        report,
        close,
        abort,
        getResults,
    };
    return eyes;
    async function check({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log('Request "check" called for target', target, 'with settings', settings);
        [target.image, target.dom, settings.domMapping] = await Promise.all([
            upload({ name: 'image', resource: target.image, logger }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true, logger }),
            settings.domMapping && upload({ name: 'domMapping', resource: settings.domMapping, gzip: true, logger }),
        ]);
        const response = await req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'check',
            method: 'POST',
            body: toServerMatchOptions({ target, settings }),
            expected: 200,
            logger,
        });
        const result = (await response.json());
        logger.log('Request "check" finished successfully with body', result);
        return {
            userTestId: test.userTestId,
            ...result,
        };
    }
    async function checkAndClose({ target, settings, logger = mainLogger, }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        if (!supportsCheckAndClose) {
            logger.log('Request "checkAndClose" is not supported by the server, using "check" and "close" requests instead');
            await check({ target, settings, logger });
            return close({ settings, logger });
        }
        logger.log('Request "checkAndClose" called for target', target, 'with settings', settings);
        [target.image, target.dom, settings.domMapping] = await Promise.all([
            upload({ name: 'image', resource: target.image, logger }),
            target.dom && upload({ name: 'dom', resource: target.dom, gzip: true, logger }),
            settings.domMapping && upload({ name: 'domMapping', resource: settings.domMapping, gzip: true, logger }),
        ]);
        const matchOptions = toServerMatchOptions({ target, settings });
        resultResponsePromise = req(`./api/sessions/running/${encodeURIComponent(test.testId)}/matchandend`, {
            name: 'checkAndClose',
            method: 'POST',
            body: {
                ...matchOptions,
                options: {
                    ...matchOptions.options,
                    removeSession: false,
                    removeSessionIfMatching: settings.ignoreMismatch,
                    updateBaselineIfNew: settings.updateBaselineIfNew,
                    updateBaselineIfDifferent: settings.updateBaselineIfDifferent,
                },
            },
            query: {
                updateBaseline: test.isNew ? settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfNew : settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfDifferent,
            },
            hooks: {
                beforeRetry({ response, stop }) {
                    if ((response === null || response === void 0 ? void 0 : response.status) === 404)
                        return stop;
                },
            },
            expected: 200,
            logger,
        });
        return resultResponsePromise
            .then(response => {
            if (response.status === 404) {
                supportsCheckAndClose = false;
                return checkAndClose({ target, settings });
            }
            else {
                logger.log('Request "checkAndClose" finished successfully');
            }
        })
            .catch(() => undefined);
    }
    async function close({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "close" called for test ${test.testId} with settings`, settings);
        if (resultResponsePromise) {
            logger.log(`Request "close" called for test ${test.testId} that was already stopped`);
            return;
        }
        resultResponsePromise = report({ settings, logger }).then(() => req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'close',
            method: 'DELETE',
            query: {
                aborted: false,
                updateBaseline: test.isNew ? settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfNew : settings === null || settings === void 0 ? void 0 : settings.updateBaselineIfDifferent,
            },
            expected: 200,
            logger,
        }));
        return resultResponsePromise
            .then(() => {
            logger.log('Request "close" finished successfully');
        })
            .catch(() => undefined);
    }
    async function abort({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "abort" called for test ${test.testId} with settings`, settings);
        if (resultResponsePromise) {
            logger.log(`Request "abort" called for test ${test.testId} that was already stopped`);
            return;
        }
        abortReason = settings === null || settings === void 0 ? void 0 : settings.reason;
        resultResponsePromise = report({ settings, logger }).then(() => req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'abort',
            method: 'DELETE',
            query: {
                aborted: true,
            },
            expected: 200,
            logger,
        }));
        return resultResponsePromise
            .then(() => {
            logger.log('Request "abort" finished successfully');
        })
            .catch(() => undefined);
    }
    async function getResults({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "getResults" called for test ${test.testId} with settings`, settings);
        if (!resultResponsePromise) {
            logger.warn(`The test with id "${test.testId}" is going to be auto aborted`);
            await abort({ settings, logger });
        }
        const response = await resultResponsePromise;
        const results = await response.json().then((result) => {
            var _a;
            result.userTestId = test.userTestId;
            result.url = test.resultsUrl;
            result.isNew = test.isNew;
            result.initializedAt = test.initializedAt;
            result.keepIfDuplicate = test.keepIfDuplicate;
            result.eyesServer = test.eyesServer;
            result.reason = abortReason;
            // for backwards compatibility with outdated servers
            (_a = result.status) !== null && _a !== void 0 ? _a : (result.status = result.missing === 0 && result.mismatches === 0 ? 'Passed' : 'Unresolved');
            return [result];
        });
        logger.log('Request "getResults" finished successfully with body', results);
        return results;
    }
    async function report({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger);
        logger.log(`Request "report" called for test ${test.testId} with settings`, settings);
        if (!(settings === null || settings === void 0 ? void 0 : settings.testMetadata) || utils.types.isEmpty(settings.testMetadata))
            return;
        try {
            await req(`./api/sessions/running/${encodeURIComponent(test.testId)}/selfhealdata`, {
                name: 'reportSelfHealing',
                method: 'PUT',
                body: {
                    operations: settings.testMetadata.map(item => {
                        return { old: item === null || item === void 0 ? void 0 : item.originalSelector, new: item === null || item === void 0 ? void 0 : item.successfulSelector, timestamp: new Date().toISOString() };
                    }),
                },
                expected: 200,
                logger,
            });
        }
        catch (error) {
            logger.warn(error);
        }
    }
}
exports.makeEyesRequests = makeEyesRequests;
function makeFunctionalSessionRequests({ core, test, req: defaultReq, fetch, logger: mainLogger, }) {
    let resultResponsePromise;
    const req = defaultReq !== null && defaultReq !== void 0 ? defaultReq : (0, req_eyes_1.makeReqEyes)({ settings: test.eyesServer, fetch, logger: mainLogger });
    const functionalSession = {
        core,
        test,
        get running() {
            return !resultResponsePromise;
        },
        report,
        close,
        abort,
        getResults,
    };
    return functionalSession;
    async function close({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "close" called for test ${test.testId} with settings`, settings);
        if (resultResponsePromise) {
            logger.log(`Request "close" called for test ${test.testId} that was already stopped`);
            return;
        }
        resultResponsePromise = report({ settings, logger }).then(() => {
            var _a;
            return req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
                name: 'close',
                method: 'DELETE',
                query: { aborted: false, nonVisualStatus: (_a = settings === null || settings === void 0 ? void 0 : settings.status) !== null && _a !== void 0 ? _a : 'Completed' },
                expected: 200,
                logger,
            });
        });
        return resultResponsePromise
            .then(() => {
            logger.log('Request "close" finished successfully');
        })
            .catch(() => undefined);
    }
    async function abort({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "abort" called for test ${test.testId} with settings`, settings);
        if (resultResponsePromise) {
            logger.log(`Request "abort" called for test ${test.testId} that was already stopped`);
            return;
        }
        resultResponsePromise = report({ settings, logger }).then(() => req(`./api/sessions/running/${encodeURIComponent(test.testId)}`, {
            name: 'abort',
            method: 'DELETE',
            query: {
                aborted: true,
            },
            expected: 200,
            logger,
        }));
        return resultResponsePromise
            .then(() => {
            logger.log('Request "abort" finished successfully');
        })
            .catch(() => undefined);
    }
    async function getResults({ settings, logger = mainLogger, } = {}) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "getResults" called for test ${test.testId} with settings`, settings);
        if (!resultResponsePromise) {
            logger.warn(`The test with id "${test.testId}" is going to be auto aborted`);
            await abort({ settings, logger });
        }
        const response = await resultResponsePromise;
        const results = await response.json().then((result) => {
            result.userTestId = test.userTestId;
            result.url = test.resultsUrl;
            result.initializedAt = test.initializedAt;
            result.keepIfDuplicate = test.keepIfDuplicate;
            result.eyesServer = test.eyesServer;
            return [result];
        });
        logger.log('Request "getResults" finished successfully with body', results);
        return results;
    }
    async function report({ settings, logger = mainLogger }) {
        logger = logger.extend(mainLogger, { tags: [`core-request-${utils.general.shortid()}`] });
        logger.log(`Request "report" called for test ${test.testId} with settings`, settings);
        if (!(settings === null || settings === void 0 ? void 0 : settings.testMetadata) || utils.types.isEmpty(settings.testMetadata))
            return;
        try {
            await req(`./api/sessions/running/${encodeURIComponent(test.testId)}/selfhealdata`, {
                name: 'reportSelfHealing',
                method: 'PUT',
                body: {
                    operations: settings.testMetadata.map(item => {
                        return { old: item === null || item === void 0 ? void 0 : item.originalSelector, new: item === null || item === void 0 ? void 0 : item.successfulSelector, timestamp: new Date().toISOString() };
                    }),
                },
                expected: 200,
                logger,
            });
        }
        catch (error) {
            logger.warn(error);
        }
    }
}
exports.makeFunctionalSessionRequests = makeFunctionalSessionRequests;
function toServerMatchOptions({ target, settings }) {
    var _a, _b;
    return {
        appOutput: {
            title: target.name,
            screenshotUrl: target.image,
            domUrl: target.dom,
            domMappingUrl: settings.domMapping,
            location: target.locationInViewport && utils.geometry.round(target.locationInViewport),
            pageCoverageInfo: settings.pageId && {
                pageId: settings.pageId,
                imagePositionInPage: target.locationInView && utils.geometry.round(target.locationInView),
                ...(target.fullViewSize && utils.geometry.round(target.fullViewSize)),
            },
        },
        options: {
            imageMatchSettings: {
                ignore: toServerRegion({ regions: settings.ignoreRegions }),
                layout: toServerRegion({ regions: settings.layoutRegions }),
                strict: toServerRegion({ regions: settings.strictRegions }),
                content: toServerRegion({ regions: settings.contentRegions }),
                floating: toServerRegion({ regions: settings.floatingRegions }),
                accessibility: toServerRegion({ regions: settings.accessibilityRegions }),
                accessibilitySettings: settings.accessibilitySettings,
                ignoreDisplacements: settings.ignoreDisplacements,
                ignoreCaret: settings.ignoreCaret,
                enablePatterns: settings.enablePatterns,
                matchLevel: (_a = settings.matchLevel) !== null && _a !== void 0 ? _a : 'Strict',
                useDom: (_b = settings.useDom) !== null && _b !== void 0 ? _b : false,
                densityMetrics: settings.densityMetrics,
            },
            name: settings.name,
            source: target.source,
            renderId: settings.renderId,
            variantId: settings.userCommandId,
            ignoreMismatch: settings.ignoreMismatch,
            ignoreMatch: settings.ignoreMatch,
            forceMismatch: settings.forceMismatch,
            forceMatch: settings.forceMatch,
            replaceLast: settings.replaceLast,
        },
    };
}
function toServerRegion({ regions, }) {
    return regions === null || regions === void 0 ? void 0 : regions.map(region => {
        var _a;
        const options = {};
        if (utils.types.has(region, 'region')) {
            options.regionId = region.regionId;
            if (utils.types.has(region, 'type')) {
                options.type = region.type;
            }
            if (utils.types.has(region, 'offset')) {
                const offset = region.offset;
                options.maxUpOffset = offset.top;
                options.maxDownOffset = offset.bottom;
                options.maxLeftOffset = offset.left;
                options.maxRightOffset = offset.right;
            }
            region = utils.geometry.round(utils.geometry.padding(region.region, (_a = region.padding) !== null && _a !== void 0 ? _a : 0));
        }
        return { left: region.x, top: region.y, width: region.width, height: region.height, ...options };
    }).sort((region1, region2) => {
        if (region1.top !== region2.top)
            return region1.top > region2.top ? 1 : -1;
        else if (region1.left !== region2.left)
            return region1.left > region2.left ? 1 : -1;
        else
            return 0;
    }).reduce(deduplicatedRegionIds(), []);
    function deduplicatedRegionIds() {
        const stats = {};
        return (regions, region, index) => {
            if (!region.regionId)
                return regions.concat(region);
            if (!stats[region.regionId]) {
                stats[region.regionId] = { firstIndex: index, count: 1 };
                return regions.concat(region);
            }
            const stat = stats[region.regionId];
            if (stat.count === 1) {
                regions[stat.firstIndex] = { ...regions[stat.firstIndex], regionId: `${region.regionId} (${stat.count})` };
            }
            stat.count += 1;
            return regions.concat({ ...region, regionId: `${region.regionId} (${stat.count})` });
        };
    }
}
