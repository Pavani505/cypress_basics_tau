"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeCheck = void 0;
const nml_client_1 = require("@applitools/nml-client");
const driver_1 = require("@applitools/driver");
const take_screenshots_1 = require("./utils/take-screenshots");
const to_base_check_settings_1 = require("../automation/utils/to-base-check-settings");
const wait_for_lazy_load_1 = require("../automation/utils/wait-for-lazy-load");
const uniquify_environments_1 = require("../automation/utils/uniquify-environments");
const to_environment_key_1 = require("../automation/utils/to-environment-key");
const abort_error_1 = require("../errors/abort-error");
const chalk_1 = __importDefault(require("chalk"));
const utils = __importStar(require("@applitools/utils"));
const lang = __importStar(require("../lang"));
function makeCheck({ eyes, target: defaultTarget, environments: defaultEnvironments = [], spec, signal, logger: mainLogger, }) {
    return async function check({ target = defaultTarget, settings = {}, logger = mainLogger, } = {}) {
        var _a;
        // logging
        logger = logger.extend(mainLogger);
        logger.log('Command "check" is called with settings', settings);
        // input validation and sanitization
        if (!target)
            throw new Error('Method was called with no target');
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            logger.warn('Command "check" was called after test was already aborted');
            throw new abort_error_1.AbortError('Command "check" was called after test was already aborted');
        }
        const uniqueEnvironments = (0, uniquify_environments_1.uniquifyEnvironments)((_a = settings.environments) !== null && _a !== void 0 ? _a : defaultEnvironments);
        let driver = undefined;
        if ((0, driver_1.isDriver)(target, spec)) {
            driver = await (0, driver_1.makeDriver)({ spec, driver: target, reset: target === defaultTarget, logger });
            if (settings.retryTimeout) {
                // when retry timeout is set, retry checking until it passes or timeout is reached. This will stall the client test execution until it passes or timeout is reached to prevent the test from continuing and changing the state of the app
                logger.log(`Retry timeout is set to ${settings.retryTimeout}ms - will retry checking until it passes or timeout is reached`);
                const start = Date.now();
                if (await isNewTest({ eyes, driver, environments: uniqueEnvironments, logger })) {
                    await new Promise(resolve => setTimeout(resolve, settings.retryTimeout));
                }
                let asExpected = false, retries = 0;
                do {
                    retries++;
                    // generate base targets (images to be compared) and settings for each environment
                    const baseScreenshotsAndSettings = await generateBaseScreenshotsAndSettings(settings, uniqueEnvironments, eyes, logger, driver);
                    const promises = baseScreenshotsAndSettings.map(async ({ exactEnvironment: environment, baseSetting: settings, baseTarget: target }) => {
                        return await checkEnvironment({
                            eyes,
                            driver,
                            target,
                            environment,
                            signal,
                            logger,
                            settings: {
                                ...settings,
                                replaceLast: retries > 1,
                            },
                        });
                    });
                    const results = await Promise.all(promises);
                    asExpected = results.every(result => result.asExpected);
                    if (retries === 1) {
                        baseScreenshotsAndSettings.forEach(({ exactEnvironment }) => {
                            // put dummy promises in storage to tell eyes.close that all checks hepped
                            putInStorage(exactEnvironment, eyes, Promise.resolve());
                        });
                    }
                } while (!asExpected && Date.now() - start < settings.retryTimeout);
            }
            else {
                // generate base targets (images to be compared) and settings for each environment
                const baseScreenshotsAndSettings = await generateBaseScreenshotsAndSettings(settings, uniqueEnvironments, eyes, logger, driver);
                // when no retry timeout is set, queue all environment checks against the server without stalling the client test execution
                baseScreenshotsAndSettings.forEach(({ exactEnvironment: environment, baseSetting, baseTarget }) => {
                    checkInTheBackground(environment, baseTarget, baseSetting);
                });
            }
        }
        else {
            uniqueEnvironments.forEach(environment => checkInTheBackground(environment, target, settings));
        }
        function checkInTheBackground(environment, target, settings) {
            putInStorage(environment, eyes, checkEnvironment({ eyes, driver, target, environment, signal, logger, settings }));
        }
    };
    function putInStorage(environment, eyes, promise) {
        const key = (0, to_environment_key_1.toEnvironmentKey)(environment);
        let item = eyes.storage.get(key);
        if (!item) {
            item = { eyes: utils.promises.makeControlledPromise(), jobs: [] };
            eyes.storage.set(key, item);
        }
        item.jobs.push(promise.then());
        return item;
    }
}
exports.makeCheck = makeCheck;
async function isNewTest({ eyes, driver, environments, logger, }) {
    const environmentLogger = logger.extend({ tags: [`environment-${utils.general.shortid()}`] });
    return (await Promise.all(environments.map(async (environment) => await eyes.getBaseEyes({ settings: { environment, driver }, logger: environmentLogger }))))
        .map(baseEyes => baseEyes.test.isNew)
        .some(isNew => isNew);
}
async function checkEnvironment({ eyes, driver, target, environment, signal, logger, settings, }) {
    var _a, _b;
    const environmentLogger = logger.extend({ tags: [`environment-${utils.general.shortid()}`] });
    environmentLogger.log('Command "check" is called with settings', settings);
    try {
        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
            abortError({ logger: environmentLogger, message: 'Command "check" was aborted before checking' });
        }
        const baseEyes = await eyes.getBaseEyes({ settings: { environment, driver }, logger: environmentLogger });
        try {
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                abortError({
                    logger: environmentLogger,
                    message: `Command "check" was aborted before checking`,
                });
            }
            else if (!baseEyes.running) {
                abortError({
                    logger: environmentLogger,
                    message: `Check on environment with id "${(_a = baseEyes.test.environment) === null || _a === void 0 ? void 0 : _a.environmentId}" was aborted during one of the previous steps`,
                });
            }
            return await baseEyes.check({
                target,
                settings: settings,
                logger: environmentLogger,
            });
        }
        catch (error) {
            environmentLogger.error(`Check on environment with id "${(_b = baseEyes.test.environment) === null || _b === void 0 ? void 0 : _b.environmentId}" failed due to an error`, error);
            if (baseEyes.running && !(signal === null || signal === void 0 ? void 0 : signal.aborted))
                baseEyes.abort({ logger: environmentLogger, settings: { reason: error } });
        }
    }
    catch (error) {
        environmentLogger.error(`Environment with id ${environment.environmentId} failed before checking started due to an error`, error);
        error.info = { ...error.info, userTestId: eyes.test.userTestId, environment };
        throw error;
    }
    return { asExpected: false };
}
/**
 * @throws {AbortError}
 */
function abortError({ logger, message }) {
    logger.warn(message);
    throw new abort_error_1.AbortError(message);
}
/**
 * create base targets (array of screenshots) and base settings (array of check settings) for each environment
 */
async function generateBaseScreenshotsAndSettings(settings, uniqueEnvironments, eyes, logger, driver) {
    var _a;
    const driverEnvironment = await driver.getEnvironment();
    uniqueEnvironments = addMobileDeviceInfo(uniqueEnvironments, driverEnvironment);
    await beforeScreenshot();
    const shouldTakeWebScreenshot = driverEnvironment.isWeb ||
        !((_a = driverEnvironment.applitoolsLib) === null || _a === void 0 ? void 0 : _a.instrumented) ||
        settings.webview ||
        settings.screenshotMode === 'default';
    if (shouldTakeWebScreenshot) {
        return await takeWebScreenshot({
            driver,
            settings,
            environments: uniqueEnvironments,
            logger,
            eyes,
        });
    }
    else {
        // take screenshot using NML
        checkConflictingCapabilities();
        return await takeNMLScreenshot({
            driver,
            settings,
            environments: uniqueEnvironments,
            logger,
            eyes,
        });
    }
    async function beforeScreenshot() {
        var _a;
        await driver.currentContext.setScrollingElement((_a = settings.scrollRootElement) !== null && _a !== void 0 ? _a : null);
        if (settings.lazyLoad && driverEnvironment.isWeb) {
            await (0, wait_for_lazy_load_1.waitForLazyLoad)({
                context: driver.currentContext,
                settings: settings.lazyLoad !== true ? settings.lazyLoad : {},
                logger,
            });
        }
    }
    function checkConflictingCapabilities() {
        var _a;
        if ((_a = driverEnvironment.applitoolsLib) === null || _a === void 0 ? void 0 : _a.conflictingCapabilities) {
            const message = lang.applitoolsLibConflictingCapabilitiesWarning({
                conflictingCapabilities: driverEnvironment.applitoolsLib.conflictingCapabilities,
            });
            logger.console.log(chalk_1.default.yellow(message));
            logger.log(message);
        }
    }
    function addMobileDeviceInfo(environments, driverEnvironment) {
        return environments.map(environment => {
            var _a, _b;
            var _c, _d;
            if (utils.types.has(environment, 'iosDeviceInfo')) {
                (_a = (_c = environment.iosDeviceInfo).version) !== null && _a !== void 0 ? _a : (_c.version = driverEnvironment.platformVersion);
            }
            else if (utils.types.has(environment, 'androidDeviceInfo')) {
                (_b = (_d = environment.androidDeviceInfo).version) !== null && _b !== void 0 ? _b : (_d.version = driverEnvironment.platformVersion);
            }
            return environment;
        });
    }
}
async function takeWebScreenshot({ driver, settings, environments, logger, eyes, }) {
    let actualEnvironments = environments;
    if (settings.screenshotMode === 'default') {
        const { localEnvironment, renderEnvironments } = await (0, nml_client_1.getNMLEnvironmentsInfo)({
            environments: environments,
            supportedEnvironmentsUrl: eyes.test.supportedEnvironmentsUrl,
            proxy: eyes.test.eyesServer.proxy,
            logger,
        });
        actualEnvironments = localEnvironment ? [localEnvironment] : renderEnvironments;
    }
    const { elementReferences, getBaseCheckSettings } = (0, to_base_check_settings_1.toBaseCheckSettings)({ settings });
    const screenshots = await (0, take_screenshots_1.takeScreenshots)({
        driver,
        settings: {
            ...settings,
            environments: actualEnvironments,
            regionsToCalculate: elementReferences.calculate,
            calculateView: !!settings.pageId,
            domSettings: settings.sendDom ? { proxy: eyes.test.eyesServer.proxy } : undefined,
        },
        logger,
    });
    return screenshots.map(({ calculatedRegions, ...baseTarget }, i) => {
        return {
            baseTarget,
            baseSetting: getBaseCheckSettings({ calculatedRegions }),
            exactEnvironment: actualEnvironments[i],
        };
    });
}
async function takeNMLScreenshot({ driver, settings, environments, logger, eyes, }) {
    const nmlClient = await eyes.core.getNMLClient({
        driver,
        settings: { ...eyes.test.eyesServer, supportedEnvironmentsUrl: eyes.test.supportedEnvironmentsUrl },
        logger,
    });
    if (settings.scrollRootElement || settings.region || (0, to_base_check_settings_1.hasCodedRegions)(settings))
        await nmlClient.preTakeScreenshot({ logger });
    const { elementReferences, getBaseCheckSettings } = (0, to_base_check_settings_1.toBaseCheckSettings)({
        settings: {
            ...settings,
            ...(await (0, to_base_check_settings_1.extractMobileElementsIntoCheckSettings)({ settings, driver, logger })),
        },
    });
    const calculate = elementReferences.calculate;
    const screenshots = await nmlClient.takeScreenshots({
        settings: {
            environments: environments,
            fully: settings.fully,
            stitchMode: settings.stitchMode,
            hideScrollbars: settings.hideScrollbars,
            hideCaret: settings.hideScrollbars,
            overlap: settings.overlap,
            waitBeforeCapture: settings.waitBeforeCapture,
            waitBetweenStitches: settings.waitBetweenStitches,
            lazyLoad: settings.lazyLoad,
            name: settings.name,
            region: elementReferences.target,
            selectorsToFindRegionsFor: calculate.map(({ name }) => name),
            scrollRootElement: elementReferences.scrolling,
        },
        logger,
    });
    return screenshots.map(({ calculateRegions, ...baseTarget }) => {
        const aggregateCalculatedRegions = [];
        calculate.forEach(({ reference }, index) => {
            const regions = calculateRegions === null || calculateRegions === void 0 ? void 0 : calculateRegions[index];
            if (regions) {
                aggregateCalculatedRegions.push({ regions, selector: reference });
            }
            else {
                logger.log(`Regions "${reference}" was not found in the screenshot`);
            }
        });
        return {
            baseTarget: { ...baseTarget, isTransformed: true },
            baseSetting: getBaseCheckSettings({
                calculatedRegions: aggregateCalculatedRegions,
            }),
            exactEnvironment: baseTarget.environment,
        };
    });
}
