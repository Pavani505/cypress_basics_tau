const{tunnelId:tunnelId,stringifyConfig:stringifyConfig,heartbeatTimeout:heartbeatTimeout=1e4,startTunnelTimeoutThreshold:startTunnelTimeoutThreshold=1e4,stopProcessTimeout:stopProcessTimeout=5e3,stringifyloggerOptions:stringifyloggerOptions}=process.env,loggerOptions=stringifyloggerOptions?JSON.parse(stringifyloggerOptions):{mode:"development",level:"info"},{createLogger:createLogger}=require("../../src/utils"),logger=createLogger({...loggerOptions,filename:tunnelId});logger.debug({action:"process-was-started",tunnelId:tunnelId,stringifyConfig:stringifyConfig,stringifyloggerOptions:stringifyloggerOptions,heartbeatTimeout:heartbeatTimeout,startTunnelTimeoutThreshold:startTunnelTimeoutThreshold,stopProcessTimeout:stopProcessTimeout});const{promises:fs}=require("fs"),nodeCleanup=require("node-cleanup"),{TunnelConnectionPool:TunnelConnectionPool}=require("./tunnel-connection-pool.js"),TUNNEL_STATUS=require("./tunnel-status.js"),tls=require("tls");let selfKillTimeoutId,initTimeoutId;const _startTunnel=async()=>{const e=JSON.parse(stringifyConfig),t=new TunnelConnectionPool({...e,logger:logger}),o=e=>{selfKillTimeoutId=setTimeout((async()=>{logger.error({action:"self-kill-timeout",error:`TunnelId ${tunnelId}: self-kill is called`,heartbeatTimeout:heartbeatTimeout}),console.log(`TunnelId ${tunnelId}: self-kill is called`);try{await t.end()}catch(e){console.log(e),t.destroy()}finally{process.exit(1)}}),e)};process.on("message",(({status:e})=>{"ok"===e&&(void 0!==selfKillTimeoutId&&clearTimeout(selfKillTimeoutId),o(heartbeatTimeout))})),nodeCleanup(((e,o)=>{logger.info({action:"tunnel-is-closing",exitCode:e,signal:o}),process.send({status:TUNNEL_STATUS.STOPPED}),selfKillTimeoutId&&clearTimeout(selfKillTimeoutId),initTimeoutId&&clearTimeout(initTimeoutId),t.end(Number(stopProcessTimeout)).catch((e=>{logger.warn({action:"tunnel-pool-timeout",error:e.message}),t.destroy()})).finally((()=>{logger.info({action:"tunnel-process-was-closed"}),setTimeout((()=>{logger.close(),process.exit()}),1e3)}))}));try{initTimeoutId=setTimeout((()=>{process.send({status:TUNNEL_STATUS.INIT_TIMEOUT_ERROR})}),startTunnelTimeoutThreshold),await t.start(),clearTimeout(initTimeoutId),initTimeoutId=void 0,o(parseInt(heartbeatTimeout)),process.send({status:TUNNEL_STATUS.RUNNING}),logger.info({action:"tunnel-started",tunnelId:tunnelId,success:!0})}catch(e){logger.error({action:"starting-tunnel-pool-failed",error:e.message}),initTimeoutId&&clearTimeout(initTimeoutId),process.send({status:TUNNEL_STATUS.INIT_ERROR})}};_startTunnel();