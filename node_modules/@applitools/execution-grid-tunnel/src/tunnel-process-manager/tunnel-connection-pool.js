const{TunnelConnection:TunnelConnection,ErrorCircuitBreaker:ErrorCircuitBreaker}=require("../utils"),{v4:uuid}=require("uuid");class TunnelConnectionPool{constructor(e){this._isPoolShuttingDown=!1,this._haveConnectionSucceeded=!1,this._options=e,this._connectionMap=new Map,this._createConnectionMap=new Map,this._connectionStatusMap=new Map,this._availableConnectionMap=new Map,this._logger=this._options.logger,this._circuitBreaker=new ErrorCircuitBreaker({logger:this._options.logger})}async _createNewConnection(e){const{tunnelId:t,host:n,port:o,token:i,keepAliveMessage:c,connectedMessage:s,protocol:r,localProxyOptions:a,logger:l}=this._options,h=new(this._options.TunnelConnection||TunnelConnection)({keepAliveMessage:c,connectedMessage:s,logger:l,connectionId:e});return await h.connect({tunnelId:t,host:n,port:o,protocol:r,token:i,localProxyOptions:a}),h}async _handleConnectionLifecycle(){await this._circuitBreaker.waitForClosedState;const e=uuid();try{this._createConnectionMap.set(e,e);const t=await this._createNewConnection(e);this._createConnectionMap.delete(e),this._fireStatus("connected",e,t),t._remoteConnection?.on("error",(n=>{t._remoteConnection?.closed&&t._localConnection.closed?this._fireStatus("end",e):this._fireStatus("error",e,n)})),t._localConnection?.on("close",(()=>{this._fireStatus("end",e)}));t.waitForAttachingRequest().then((()=>this._fireStatus("occupied",e))),t.waitForRemoteConnectionClosing().then((()=>this._fireStatus("end",e)));return void this._circuitBreaker.resetErrorCounter()}catch(t){return this._createConnectionMap.delete(e),this._logger.warn({action:"handle-connection-lifecycle",error:t.message,id:e}),this._circuitBreaker.incErrorCounter(),this._fireStatus("error",e,t),t}}async _fireStatus(e,t,n=void 0){if(this._logger.debug(e,t),"connected"===e&&(this._connectionMap.set(t,n),this._connectionStatusMap.set(t,e),this._availableConnectionMap.set(t,t),!this._haveConnectionSucceeded)){this._haveConnectionSucceeded=!0;const e=this._options.preAllocation-this._connectionMap.size;for(let t=0;t<e;t++)this._handleConnectionLifecycle()}if("occupied"===e){if(!this._connectionStatusMap.has(t))return;this._connectionStatusMap.set(t,"occupied"),this._availableConnectionMap.delete(t),this._connectionStatusMap.delete(t)}"error"===e&&(this._availableConnectionMap.delete(t),this._connectionStatusMap.set(t,"error")),"end"===e&&(this._availableConnectionMap.delete(t),this._connectionStatusMap.delete(t),this._connectionMap.delete(t)),"occupied"!==e&&"end"!==e&&"error"!==e||this._haveConnectionSucceeded&&!this._isPoolShuttingDown&&this._availableConnectionMap.size+this._createConnectionMap.size<this._options.preAllocation&&this._connectionMap.size<this._options.maxConnections&&this._handleConnectionLifecycle(),this._logger.debug({action:"pool-statistics",available:this._availableConnectionMap.size,inCreation:this._createConnectionMap.size,total:this._connectionMap.size})}async start(){const e=await this._handleConnectionLifecycle();if(e)throw this._logger.error({action:"tunnel-pool-error",error:e.message}),e}async end(e=5e3){this._isPoolShuttingDown=!0;for(const e of this._connectionMap.values())e.end();return new Promise((async(t,n)=>{const o=setTimeout((()=>n(new Error("Timeout Error"))),e);for(;this._connectionMap.size>0;)await new Promise((e=>setTimeout(e,50)));clearTimeout(o),t()}))}destroy(){this._isPoolShuttingDown=!0;for(const e of this._connectionMap.values())e.destroy()}}module.exports={TunnelConnectionPool:TunnelConnectionPool};